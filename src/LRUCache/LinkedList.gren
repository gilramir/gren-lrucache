module LRUCache.LinkedList exposing (..)

import Dict exposing (Dict)

type LinkedList comparable v =
    LinkedList
    { firstAndLast : Maybe { firstItem: comparable, lastItem: comparable }
    , nodes : Dict comparable (Link comparable v)
    , zeroDictKey: comparable
    , zeroDictVal : v
    }


type Link comparable v =
    Link
    { previous : Maybe comparable
    , next : Maybe comparable
    , dictValue : v
    }

toDict : LinkedList comparable v -> Dict comparable v
toDict (LinkedList { nodes }) =
    Dict.map (\comparable (Link {dictValue}) -> dictValue) nodes

emptyLinkedList : comparable -> v ->  LinkedList comparable v
emptyLinkedList zeroDictKey zeroDictVal =
    LinkedList
        { firstAndLast = Nothing
        , nodes = Dict.empty
        , zeroDictKey = zeroDictKey
        , zeroDictVal = zeroDictVal
        }

pushFront : comparable -> v -> LinkedList comparable v -> LinkedList comparable v
pushFront newItem newDictValue list =
    let
        -- If a is already in the list then remove it
        (LinkedList {firstAndLast, nodes, zeroDictKey, zeroDictVal} as listToUse) =
            if has newItem list then
                (remove newItem list)
            else
                list
    in
        when firstAndLast is
            Nothing ->
                -- Nothing is in the list at all. Set this new item to the head, last and
                -- add an entry for it in the nodes map to denote it has no siblings.
                LinkedList
                    { firstAndLast = Just { firstItem = newItem, lastItem = newItem }
                    , nodes = Dict.set newItem (Link
                        { previous = Nothing
                        , next = Nothing
                        , dictValue = newDictValue
                        }) nodes
                    , zeroDictKey = zeroDictKey
                    , zeroDictVal = zeroDictVal
                    }

            Just { firstItem = firstItem, lastItem = lastItem } ->
                let
                    originalFirstLink =
                        unsafeGetLink firstItem listToUse

                    newLink =
                        (Link
                            { previous = Nothing
                            , next = Just firstItem
                            , dictValue = newDictValue
                            })
                in
                    LinkedList
                        { firstAndLast = Just { firstItem = newItem, lastItem = lastItem }
                        , nodes =
                            nodes
                                |> Dict.set newItem newLink
                                |> Dict.set firstItem
                                (Link
                                    { previous = Just newItem
                                    , next = linkNext originalFirstLink
                                    , dictValue = linkDictValue originalFirstLink
                                    })
                        , zeroDictKey = zeroDictKey
                        , zeroDictVal = zeroDictVal
                        }

unsafeGetLink : comparable -> LinkedList comparable v -> Link comparable v
unsafeGetLink item (LinkedList {nodes, zeroDictKey, zeroDictVal}) =
    Maybe.withDefault (emptyLink zeroDictKey zeroDictVal) <| Dict.get item nodes

emptyLink : comparable -> v -> Link comparable v
emptyLink zeroDictKey zeroDictVal =
    Link { previous = Nothing, next = Nothing, dictValue = zeroDictVal }


linkDictValue : Link comparable v -> v
linkDictValue (Link { dictValue }) =
    dictValue


linkNext : Link comparable v -> Maybe comparable
linkNext (Link {next})  =
    next

linkPrevious : Link comparable v -> Maybe comparable
linkPrevious (Link {previous}) =
    previous


has : comparable -> LinkedList comparable v -> Bool
has item (LinkedList {nodes}) =
    Dict.member item nodes

remove : comparable -> LinkedList comparable v -> LinkedList comparable v
remove item (LinkedList {firstAndLast, nodes, zeroDictKey, zeroDictVal} as list) =
    when firstAndLast is
        Nothing ->
            list

        Just { firstItem = firstItem, lastItem = lastItem } ->
            let
                linkMaybe =
                    Dict.get item nodes
            in
                when linkMaybe is
                    Nothing ->
                        -- That key wasn't even in this list
                        list

                    Just link ->
                        -- The key is in the list
                        when linkPrevious link is
                            Nothing ->
                                -- If there was no previous link to this item...
                                when linkNext link is
                                    Nothing ->
                                        -- AND no next link, it must have been the only thing in the list
                                        LinkedList
                                            { firstAndLast = Nothing
                                            , nodes = Dict.empty
                                            , zeroDictKey = zeroDictKey
                                            , zeroDictVal = zeroDictVal
                                            }

                                    Just nextLinkKey ->
                                        let
                                            nextLink =
                                                unsafeGetLink nextLinkKey list
                                        in
                                            -- BUT it has a next, it must have been the head. Leave the last alone, set
                                            -- that next link to the new head.
                                            LinkedList
                                                { firstAndLast = Just { firstItem = nextLinkKey, lastItem = lastItem }
                                                , nodes =
                                                    nodes
                                                        |> Dict.remove item
                                                        |> Dict.set nextLinkKey (Link
                                                            { previous = Nothing
                                                            , next = linkNext nextLink
                                                            , dictValue = linkDictValue nextLink
                                                            })
                                                , zeroDictKey = zeroDictKey
                                                , zeroDictVal = zeroDictVal
                                                }

                            Just previousLinkKey ->
                                -- If there is a previous link...
                                when linkNext link is
                                    Nothing ->
                                        -- AND there is no next, then this must be the last item
                                        let
                                            previousLink =
                                                unsafeGetLink previousLinkKey list
                                            previousLinkDictValue = linkDictValue previousLink
                                        in
                                            LinkedList
                                                { firstAndLast = Just { firstItem = firstItem, lastItem = previousLinkKey }
                                                , nodes =
                                                    nodes
                                                        |> Dict.set previousLinkKey (Link
                                                            { previous = linkPrevious previousLink
                                                            , next = Nothing
                                                            , dictValue = previousLinkDictValue
                                                            })
                                                        |> Dict.remove item
                                                , zeroDictKey = zeroDictKey
                                                , zeroDictVal = zeroDictVal
                                                }

                                    Just nextLinkKey ->
                                        let
                                            nextLink =
                                                unsafeGetLink nextLinkKey list

                                            nextLinkDictValue = linkDictValue nextLink

                                            previousLink =
                                                unsafeGetLink previousLinkKey list

                                            previousLinkDictValue = linkDictValue previousLink
                                        in
                                            -- AND there is a next, then this item has two siblings and they need to point to each other.
                                            -- It must not have been the first or last item
                                            LinkedList
                                                { firstAndLast = Just { firstItem = firstItem, lastItem = lastItem }
                                                , nodes =
                                                    nodes
                                                        |> Dict.set previousLinkKey (Link
                                                            { previous = linkPrevious previousLink
                                                            , next = Just nextLinkKey
                                                            , dictValue = previousLinkDictValue
                                                            })
                                                        |> Dict.set nextLinkKey (Link
                                                            { previous = Just previousLinkKey
                                                            , next = linkNext nextLink
                                                            , dictValue = nextLinkDictValue
                                                            })
                                                        |> Dict.remove item
                                                , zeroDictKey = zeroDictKey
                                                , zeroDictVal = zeroDictVal
                                                }

unsafeLast : LinkedList comparable v -> comparable
unsafeLast (LinkedList {firstAndLast, zeroDictKey}) =
    when firstAndLast is
        Nothing ->
            zeroDictKey

        Just { firstItem = _ , lastItem = lastItem } ->
            lastItem

